{"version":3,"file":"policies.mjs","sources":["../../../../../../../../node_modules/@apollo/client/cache/inmemory/policies.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\nfunction argsFromFieldSpecifier(spec) {\n    return (spec.args !== void 0 ? spec.args\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n            : null);\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = /** @class */ (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        // Map from subtype names to sets of supertype names. Note that this\n        // representation inverts the structure of possibleTypes (whose keys are\n        // supertypes and whose values are arrays of subtypes) because it tends\n        // to be much more efficient to search upwards than downwards.\n        this.supertypeMap = new Map();\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\n        // RegExp objects and recorded here. Every key of this map can also be\n        // found in supertypeMap. In many cases this Map will be empty, which\n        // means no fuzzy subtype checking will happen in fragmentMatches.\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = (partialContext &&\n            (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) ||\n            object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        var storeObject = (partialContext && partialContext.storeObject) || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: (partialContext && partialContext.readField) ||\n                function () {\n                    var options = normalizeReadFieldOptions(arguments, storeObject);\n                    return policies.readField(options, {\n                        store: policies.cache[\"data\"],\n                        variables: options.variables,\n                    });\n                } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n        disableWarningsSlot.withValue(true, function () {\n            while (keyFn) {\n                var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n                if (isArray(specifierOrId)) {\n                    keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n                }\n                else {\n                    id = specifierOrId;\n                    break;\n                }\n            }\n        });\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge\n                    // Pass merge:true as a shorthand for a merge implementation\n                    // that returns options.mergeObjects(existing, incoming).\n                    : merge === true ? mergeTrueFn\n                        // Pass merge:false to make incoming always replace existing\n                        // without any warnings about data clobbering.\n                        : merge === false ? mergeFalseFn\n                            : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            // Pass false to disable normalization for this typename.\n            keyFields === false ? nullKeyFieldsFn\n                // Pass an array of strings to use those fields to compute a\n                // composite ID for objects of this typename.\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n                    // Pass a function to take full control over identification.\n                    : typeof keyFields === \"function\" ? keyFields\n                        // Leave existing.keyFn unchanged if above cases fail.\n                        : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        // Pass false to disable argument-based differentiation of\n                        // field identities.\n                        keyArgs === false ? simpleKeyArgsFn\n                            // Pass an array of strings to use named arguments to\n                            // compute a composite identity for the field.\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n                                // Pass a function to take full control over field identity.\n                                : typeof keyArgs === \"function\" ? keyArgs\n                                    // Leave existing.keyFn unchanged if above cases fail.\n                                    : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, 6, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old)\n                delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = (this.typePolicies[typename] = Object.create(null));\n            policy_1.fields = Object.create(null);\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            var supertypes_1 = this.supertypeMap.get(typename);\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes_1 = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach(function (supertype) {\n                                return supertypes_1.add(supertype);\n                            });\n                        }\n                    }\n                });\n            }\n            if (supertypes_1 && supertypes_1.size) {\n                supertypes_1.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return (fieldPolicies[fieldName] ||\n                (createIfMissing && (fieldPolicies[fieldName] = Object.create(null))));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            globalThis.__DEV__ !== false && invariant.warn(7, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    // Start checking fuzzy subtypes only after exhausting all\n                    // non-fuzzy subtypes (after the final iteration of the loop).\n                    i === workQueue_1.length - 1 &&\n                    // We could wait to compare fragment.selectionSet to result\n                    // after we verify the supertype, but this check is often less\n                    // expensive than that search, and we will have to do the\n                    // comparison anyway whenever we find a potential match.\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName =\n                fieldSpec.field ?\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\n                objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions,\n            ]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename: typename,\n            fieldName: field.name.value,\n            field: field,\n            variables: context.variables,\n        }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\n        globalThis.__DEV__ !== false && invariant.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw newInvariantError(9);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n//# sourceMappingURL=policies.js.map"],"names":["Policies","existing","incoming","supertypeSet"],"mappings":"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","x_google_ignoreList":[0]}